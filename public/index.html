<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.babylonjs.com/v7.34.1/babylon.js"></script>
  <meta charset="UTF-8">
  <style>
    .title{
        font-family: Arial, Helvetica, sans-serif;
        text-align: center;
        font-size: 35px;
    }
    .field{
        background-color: grey;
        padding: 20px;
        border-radius: 10px;
        border-style: double;
        border-width:5px;
        border-color:black;
    }
    canvas {
        margin: 0;
        padding: 0;
        width: 60%;
        height: 60%;     
        font-size: 0;
    }
    .render-canvas{
      text-align: center;
    }
    #slice-manager {
      display: flex;
      flex-direction: column; /* stack buttons vertically */
      gap: 10px; /* spacing between buttons */
    }
    .canvas{
        text-align: center;
    }
    .header{
      text-align: center;
    }
    #slice-manager button {
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1 class="title">Optimal Cube Shapes</h1>

  <div class="field">
    <h2 class="header">Spheres, Ovoids, and Toroids</h2>
    <form id="parameters">
        <select name="shape" id="shape" type="shape">
        <option value="none">List of common shapes</option>
        <option value="sphere">Sphere</option>
        <option value="ellipse">3D ellipse</option>
        <option value="toroid">toroid</option>
        <option value="elliptical toroid">elliptical toroid</option>
        <option value="elliptical toroid with elliptical cross section">elliptical toroid with elliptical cross section</option>
        </select>
    </form>
    <div id="specifications"></div>
  </div>
  <div class = "field">
    <h2 class = "header">Lathe</h2>
    <h3 class = "header">Define your own shape using an interval of a function, the line created by this interval is spun 360 degrees to form a 
      radially symetrical shape Single variable functions only with x as the variable, (x + 8)^2.
    </h3>
    <form>
        <select name="lathe" id="lathe" type="lathe">
        <option value="off">Off</option>
        <option value="on">On</option>
        </select>
    </form>
    <div id = "latheSpecifications">
    </div>
  </div>

  <div class="render-canvas">
      <canvas id="render-canvas"></canvas>
        <div id = "slice-manager">
        <button onclick="viewSliceMap()">View slice map</button>
      </div>
  </div>

  <div id="information" class = "field"></div>

  <form id="dataForm">
    <input type="text" id="userInput" placeholder="Enter message">
    <button type="submit">Send to Server</button>
  </form>

  <script src="https://cdn.jsdelivr.net/npm/mathjs@13.2.0/lib/browser/math.js"></script>

  <script>

    let sliceMap = false;
    let sliceLayer = 0;
    let boundx = 0;
    let boundy = 0;
    let boundz = 0;
    let globalParity = 0;
    let globalY = 0;

    function displaySlice(y){
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(globalParity == 1){
          for(x = 0; x < boundx; x++){
            for(z = 0; z < boundz; z++){
                if(y >= 0){
                if(map[(y * boundx * boundz) + (x * boundz) + z] == 1){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                    } else {
                      latheQuad(x, y, z);
                    }
                }
              } else {
                if(map[(-1 * y * boundx * boundz) + (x * boundz) + z] == 1){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                    } else {
                      latheQuad(x, y, z);
                    }
                }
              }

            }
          }
      }
      displayInformation(y);
    }

    function viewSliceMap(){
      if(sliceMap == false){
        sliceMap = true;
        document.getElementById("slice-manager").innerHTML = `
          <button onclick="viewSliceMap()">View slice map</button>
          <button onclick="upLayer()">Up a layer</button>
          <button onclick="downLayer()">Down a layer</button>
        `
        displaySlice(globalY);
      } else if (sliceMap == true) {
        sliceMap = false;
        document.getElementById("slice-manager").innerHTML = `
          <button onclick="viewSliceMap()">View slice map</button>
        `
      }
    }
    function upLayer(){
      globalY += 1;
      displaySlice(globalY);
    }
    function downLayer(){
      globalY -= 1;
      displaySlice(globalY);
    }

    let shape = document.getElementById("shape");
    let lathe = document.getElementById("lathe");
    let specifications = document.getElementById("specifications");
    let latheSpecifications = document.getElementById("latheSpecifications");
    let volume = 0;
    let surface = 0;
    let speech = "";
    let mode = "none";

    lathe.addEventListener("change", function(e){
      if(this.value == "on"){
            latheSpecifications.innerHTML = `
            <form id="latheParameters" novalidate>
            <label for="formula">Formula: </label>
            <input type="text" id="formula" name="formula" required>

            <label for="index1">Index 1: </label>
            <input type="text" id="index1" name="index1" required>

            <label for="index2">Index 2: </label>
            <input type="text" id="index2" name="index2" required>

            <label for="parity">0(Even) or 1(Odd)?: </label>
            <input type="text" id="parity" name="parity" required>

            <button type="submit">Generate</button>
          </form>
      `
      } else {
        latheSpecifications.innerHTML = "";
      }
    })
    
    latheSpecifications.addEventListener("submit", function(e){
      e.preventDefault();
      let equation = e.target.querySelector("#formula").value.trim();
      let index1 = e.target.querySelector("#index1").value.trim();
      let index2 = e.target.querySelector("#index2").value.trim();
      let parity = e.target.querySelector("#parity").value.trim();
      latheFunc(equation, index1, index2, parity);
    })

    specifications.addEventListener("submit", function(e) {
      if(mode == "sphere"){
          e.preventDefault();
          let radius = e.target.querySelector("#radius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(radius, radius, radius, parity);
      }
      if(mode == "ellipse"){
          e.preventDefault();
          let width = e.target.querySelector("#width").value.trim();
          let length = e.target.querySelector("#length").value.trim();
          let height = e.target.querySelector("#height").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(width, length, height, parity);
      }
      if(mode == "toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(1, 1, 1, majorRadius, minorRadius, parity);
      }
      if(mode == "elliptical toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let widthScale = e.target.querySelector("#widthScale").value.trim();
          let lengthScale = e.target.querySelector("#lengthScale").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(widthScale, lengthScale, 1,majorRadius, minorRadius, parity);
      }
      if(mode == "elliptical toroid with elliptical cross section"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let widthScale = e.target.querySelector("#widthScale").value.trim();
          let lengthScale = e.target.querySelector("#lengthScale").value.trim();
          let heightScale = e.target.querySelector("#heightScale").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(widthScale, lengthScale, heightScale, majorRadius, minorRadius, parity);
      }
    });

    shape.addEventListener("change", function () {
      specifications.innerHTML = "";
      if (this.value == "sphere") {
        mode = "sphere";
        specifications.innerHTML = `
          <form id="parameters" novalidate>
            <label for="radius">Radius:</label>

            <input type="text" id="radius" name="radius" required>
            <label for="parity">0 (Even) or 1 (Odd)?:</label>

            <input type="text" id="parity" name="parity" required>
            <button type="submit">Generate</button>
          </form>
        `;
      } else if(this.value == "ellipse"){
          mode = "ellipse";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="width">width: </label>
              <input type="text" id="width" name="width" required>

              <label for="length">length:</label>
              <input type="text" id="length" name="length" required>

              <label for="height">height:</label>
              <input type="text" id="height" name="height" required>

              <label for="parity">0 (Even) or 1 (Odd)?: </label>
              <input type="text" id="parity" name="parity" required>

              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "toroid"){
          mode = "toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="text" id="majorRadius" name="majorRadius" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="text" id="minorRadius" name="minorRadius" required>

              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid"){
          mode = "elliptical toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="text" id="majorRadius" name="majorRadius" required>

              <label for="widthScale">Width Scale:</label>
              <input type="text" id="widthScale" name="widthScale" required>

              <label for="lengthScale">Length Scale:</label>
              <input type="text" id="lengthScale" name="lengthScale" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="text" id="minorRadius" name="minorRadius" required>

              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid with elliptical cross section"){
          mode = "elliptical toroid with elliptical cross section";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="text" id="majorRadius" name="majorRadius" required>

              <label for="widthScale">Width Scale:</label>
              <input type="text" id="widthScale" name="widthScale" required>

              <label for="lengthScale">Length Scale:</label>
              <input type="text" id="lengthScale" name="lengthScale" required>

              <label for="heightScale">Height Scale:</label>
              <input type="text" id="heightScale" name="heightScale" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="text" id="minorRadius" name="minorRadius" required>

              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <button type="submit">Generate</button>
            </form>
            `;
        }
    });

    function displayInformation(speech){
      information.innerHTML = speech;
    }

    // Babylon startup stuff
    const canvas = document.getElementById("render-canvas");
    const engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: true,
      stencil: true
    });
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.9);
    function renderLoop() {
    scene.render();
    }
    engine.runRenderLoop(renderLoop);
    const camera = new BABYLON.ArcRotateCamera(
    "camera",
    Math.PI / 2,
    Math.PI / 4,
    5,
    new BABYLON.Vector3(0, 0, 0),
    scene
    );
    camera.attachControl(canvas, true);

    if('ontouchstart' in window || navigator.maxTouchPoints == 0){
    canvas.addEventListener("wheel", function (event) {
    event.preventDefault();
    }, { passive: false });}

    // Cubes!!!

    let cubes = []
    
    const boxMaterial = new BABYLON.StandardMaterial("material", scene);
    boxMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    const hl = new BABYLON.HighlightLayer("hl", scene);

    function cube(x, y, z){
        cubes.push(BABYLON.Mesh.CreateBox("box", 1, scene))
        cubes[cubes.length - 1].material = boxMaterial;
        cubes[cubes.length - 1].renderOutline = true;
        cubes[cubes.length - 1].outlineColor = BABYLON.Color3.Black();
        cubes[cubes.length - 1].enableEdgesRendering();
        cubes[cubes.length - 1].edgesWidth = 1.0;
        cubes[cubes.length - 1].edgesColor = new BABYLON.Color3(0, 0, 0);
        cubes[cubes.length - 1].position.x = x;
        cubes[cubes.length - 1].position.y = y;
        cubes[cubes.length - 1].position.z = z;
    }

    let map = []
    let anchorPoints = []

    // SPHERE!!

    function volumeQuad(x, y, z){
      // Mostly used by the sphere function to mimic the quad() function to determine volume.
        if(x == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else if (z == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else {
          volume += 4

        if (y != 0){
          volume += 4
        }

        }
    }

    function quad(x, y, z){

      /*
          This is for odd spheres. The line of symetry goes directory through a block, causing it to be drawn twice. If a coordinate is zero, special procedures
          must be used to prevent cubes from being drawn on top of each other.
      */

        if(x == 0){
          cube(x, y, z);
          cube(x, y, -1 * z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(x, -1 * y, -1 * z);
            surface += 2
          }
        } else if (z == 0){
          cube(x, y, z);
          cube(-1 * x, y, z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(-1 * x, -1 * y, z);
            surface += 2
          }
        } else {
          cube(x, y, z);
          cube(-1 * x, y, z);
          cube(x, y, -1 * z);
          cube(-1 * x, y, -1 * z);
          surface += 4

        if (y != 0){
          cube(x, -1 * y, z);
          cube(-1 * x, -1 * y, z);
          cube(x, -1 * y, -1 * z);
          cube(-1 * x, -1 * y, -1 * z);
          surface += 4
        }

        }
    }

    function evenQuad(x, y, z){

      /*
          This is for even sphere where the line of symetry goes in between two cubes. When I mirror cubes, I move them over one to create the even symetry.
          Otherwise this just creates a normal odd sphere.
      */

        cube(x, y, z);
        cube(-1 * x - 1, y, z);
        cube(x, y, -1 * z - 1);
        cube(-1 * x - 1, y, -1 * z - 1);

        cube(x, -1 * y - 1, z);
        cube(-1 * x - 1, -1 * y - 1, z);
        cube(x, -1 * y - 1, -1 * z - 1);
        cube(-1 * x - 1, -1 * y - 1, -1 * z - 1);

        surface += 8

    }
    
    function volumeLatheQuad(x,y,z){
        if(x == 0 && z == 0){
          volume += 1
        } else if(x == 0){
          volume += 2
        } else if (z == 0){
          volume += 2
        } else {
          volume += 4

        }
    }

    function latheQuad(x, y, z){
        if(x == 0 && z == 0){
          cube(x,y,z);
          surface += 1
        } else if(x == 0){
          cube(x, y, z);
          cube(x, y, -1 * z);
          surface += 2
        } else if (z == 0){
          cube(x, y, z);
          cube(-1 * x, y, z);
          surface += 2
        } else {
          cube(x, y, z);
          cube(-1 * x, y, z);
          cube(x, y, -1 * z);
          cube(-1 * x, y, -1 * z);
          surface += 4

        }
    }

    function evenLatheQuad(x,y,z){
        cube(x, y, z);
        cube(-1 * x - 1, y, z);
        cube(x, y, -1 * z - 1);
        cube(-1 * x - 1, y, -1 * z - 1);

        surface += 4
    }
    /*
      In a nutshell, the ellipse function works by checking every single corner of each cube to see if it is less than the radius using the equation
      x^2/w^2 + y^2/h^2 + z^2/l^2 <= 1. Each successful cube placement is inserted into the map[] array for later optimization.

      This function only calculates one eighth of the sphere, the quad() function mirrors the cube across all other "wedges" of the sphere. 
      Every coordinate is at some point multiplied by -1, and in even spheres 1 will also be added as well.
    */

    function ellipse(length, width, height, parity){
      surface = 0;
      volume = 0;
      boundx = width;
      boundy = height;
      boundz = length;
      sliceMap = true;
      viewSliceMap();
      // filling the map array with 0's
      map = new Array((length + 1) * (width + 1) * (height + 1)).fill(0);
      // Getting rid of all pre existing cubes from other functions
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(parity == "1"){
        globalParity = 1;
        // The seed cube
        cube(0, 0, 0);
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                if(y == 0 && x == 0){
                  volume += 2;
                } else if (x == 0 && z == 0){
                  volume += 2;
                } else if (z == 0 && y == 0){
                  volume += 2;
                } else if(y == 0 || z == 0|| x == 0){
                  volume += 4;
                } else {
                  volume += 8;
                }
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y, z);
                      surface += 2;
                    } else {
                      quad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if (parity == "0"){
        globalParity = 0;
        // The seed cube
        cube(0, 0, 0);
        cube(0, 0, 0);
        cube(-1, 0, 0);
        cube(0, -1, 0);
        cube(-1, -1, 0);
        cube(0, 0, -1);
        cube(-1, 0, -1);
        cube(0, -1, -1);
        cube(-1, -1, -1);
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                volume += 8;
              }
            }
          }
        }
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      evenQuad(x, y, z);
                    } else {
                      map[y * (width * length) + x * length + z] = 2;
                      evenQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }

    /*
      The toroid function works similarly to the ellipse() function, but the equation is :
      (Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r
    */

  function toroid(scaleWidth, scaleLength, scaleHeight, majorRadius, minorRadius, parity) {

      sliceMap = true;
      viewSliceMap();

      surface = 0;
      volume = 0;
      let a = scaleWidth;
      let b = scaleLength;
      let c = scaleHeight;
      let R = majorRadius;
      let r = minorRadius;

      let width = (parseInt(majorRadius) + parseInt(minorRadius)) * Math.ceil(scaleWidth);
      let length = parseInt(minorRadius) * parseInt(scaleHeight);
      let height = (parseInt(majorRadius) + parseInt(minorRadius)) * Math.ceil(scaleLength);
      
      boundx = width;
      boundy = height;
      boundz = length;
      // filling the map array with 0's
      map = new Array((majorRadius * Math.ceil(scaleWidth) + 1) * (majorRadius * Math.ceil(scaleLength) + 1) * (minorRadius * Math.ceil(scaleHeight) + 1)).fill(0);

      //I made my own psudo .fill(0) function because for whatever reason, 
      // .fill(0) does not actually fill every voxel with a 0. I'm not sure why, but I made this to fix it.

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              map[(y * width * length) + (x * length) + z] = 0;
            }
          }
        }

      // Getting rid of all pre existing cubes from other functions
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(parity == "1"){ 
        globalParity = 1;
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if((Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r){
                map[(y * width * length) + (x * length) + z] = 1;
                if(y == 0 && x == 0){
                  volume += 2;
                } else if (x == 0 && z == 0){
                  volume += 2;
                } else if (z == 0 && y == 0){
                  volume += 2;
                } else if(y == 0 || z == 0|| x == 0){
                  volume += 4;
                } else {
                  volume += 8;
                }
              }
            }
          }
        }
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if(x*x + y*y + z*z < Math.pow(majorRadius - minorRadius,2)){
                map[(y * width * length) + (x * length) + z] = 0;
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */

        map[height * (width * length) + 0 * length + 0] = 0

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1
              || (map[y * (width * length) + (x - 1) * length + z] == 0 && x != 0)
              || map[(y - 1) * (width * length) + x * length + z] == 0){
                  if(map[y * (width * length) + x * length + z] == 1 && x != width){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y, z);
                      surface += 2;
                    } else {
                      quad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if (parity == "0"){
        globalParity = 0;
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if((Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r){
                map[(y * width * length) + (x * length) + z] = 1;
                volume += 8;
              }
            }
          }
        }
        // There were issues with generating the middle of the toroid. There were small "growths" on the edges and in the center of the hole
        // This function basically clears the entire center to make sure those growths do not occur.
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              if(x*x + y*y + z*z < Math.pow(majorRadius - minorRadius,2)){
                map[(y * width * length) + (x * length) + z] = 0;
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor.
        */

        map[height * (width * length) + 0 * length + 0] = 0

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1
              || (map[y * (width * length) + (x - 1) * length + z] == 0 && x != 0)
              || map[(y - 1) * (width * length) + x * length + z] == 0){
                  if(map[y * (width * length) + x * length + z] == 1 && x != width){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y - 1, z);
                      cube(x - 1, y, z);
                      cube(x - 1, -1 * y - 1, z);

                      cube(x, y, z - 1);
                      cube(x, -1 * y - 1, z - 1);
                      cube(x - 1, y, z - 1);
                      cube(x - 1, -1 * y - 1, z - 1);
                      surface += 8;
                    } else {
                      map[y * (width * length) + x * length + z] = 2;
                      evenQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }

    /*
    
    */

    function latheFunc(equation, index1, index2, parity){
      surface = 0;
      volume = 0;
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      let expr = math.parse(equation);
      let F = (val) => expr.evaluate({ x: val });
      let secondIndex = 0;
      let firstIndex = 0;
      index1 = Math.abs(index1);
      index2 = Math.abs(index2);
      if(index1 < index2){
        firstIndex = index1;
        secondIndex = index2;
      } else if (index2 <= index1){
        firstIndex = index2;
        secondIndex = index1;
      }
      let radius = 0;
      let y = 0;
      let radiusStack = [];
        for(y = firstIndex; y <= secondIndex; y++){
          if(F(y) < 0){
            radiusStack.push(0);
          } else {
            radiusStack.push(Math.floor(F(y)));
          }
          if(F(y) > radius){
            radius = Math.floor(F(y)) + 1;
          }
        }
        boundx = radius;
        boundy = radiusStack.length;
        boundz = radius;
      if(parity == "1"){
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius; x++){
            for(z = 0; z <= radius; z++){
              if((x + 0.5)*(x + 0.5) + (z + 0.5)*(z + 0.5) <= radiusStack[y] * radiusStack[y]){
                map[((y) * radius * radius) + (x * radius) + z] = 1;
                volumeLatheQuad(x,y,z)
              } else {
                map[((y) * radius * radius) + (x * radius) + z] = 0;
              }
            }
          }
        }
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius - 1; x++){
            for(z = 0; z <= radius - 1; z++){
              if(map[(y + 1) * (radius * radius) + x * radius + z] == 0 
              || map[y * (radius * radius) + (x + 1) * radius + z] == 0
              || map[y * (radius * radius) + x * radius + (z + 1)] == 0
              || z == radius - 1 || x == radius - 1 || y == 1
              || (map[y * (radius * radius) + (x - 1) * radius + z] == 0 && x != 0)
              || map[(y - 1) * (radius * radius) + x * radius + z] == 0){
                  if(map[y * (radius * radius) + x * radius + z] == 1 && x != radius && y != 0){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      surface += 1;
                    } else {
                      map[y * (radius * radius) + x * radius + z] = 2;
                      latheQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if(parity == "0"){
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius; x++){
            for(z = 0; z <= radius; z++){
              if((x + 0.5)*(x + 0.5) + (z + 0.5)*(z + 0.5) <= radiusStack[y] * radiusStack[y]){
                map[((y) * radius * radius) + (x * radius) + z] = 1;
                volume += 4;
              } else {
                map[((y) * radius * radius) + (x * radius) + z] = 0;
              }
            }
          }
        }
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius - 1; x++){
            for(z = 0; z <= radius - 1; z++){
              if(map[(y + 1) * (radius * radius) + x * radius + z] == 0 
              || map[y * (radius * radius) + (x + 1) * radius + z] == 0
              || map[y * (radius * radius) + x * radius + (z + 1)] == 0
              || z == radius - 1 || x == radius - 1 || y == 1
              || (map[y * (radius * radius) + (x - 1) * radius + z] == 0 && x != 0)
              || map[(y - 1) * (radius * radius) + x * radius + z] == 0){
                  if(map[y * (radius * radius) + x * radius + z] == 1 && x != radius && y != 0){
                    if(x == 0 && z == 0){
                      evenLatheQuad(x, y, z);
                      surface += 1;
                    } else {
                      map[y * (radius * radius) + x * radius + z] = 2;
                      evenLatheQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }
    // Send data
    document.getElementById('dataForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const message = document.getElementById('userInput').value;

      const res = await fetch('/api/data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      });

      const result = await res.json();
      alert(result.status);

      });
  </script>
</body>
</html>