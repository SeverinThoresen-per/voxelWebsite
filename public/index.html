<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.babylonjs.com/v7.34.1/babylon.js"></script>
  <meta charset="UTF-8">
  <style>
    .title{
        font-family: Arial, Helvetica, sans-serif;
        text-align: center;
        font-size: 35px;
    }
    .field{
        background-color: grey;
        padding: 20px;
        border-radius: 10px;
        border-style: double;
        border-width:5px;
        border-color:black;
    }
    canvas {
        margin: 0;
        padding: 0;
        width: 60%;
        height: 60%;     
        font-size: 0;
    }
    .render-canvas{
      text-align: center;
    }
    .slice-canvas{
      text-align: center;
    } 
    .canvas{
        text-align: center;
    }
  </style>
</head>
<body>
  <h1 class="title">Optimal Cube Shapes</h1>

  <div class="field">
    <form id="parameters">
        <select name="shape" id="shape" type="shape">
        <option value="none">List of common shapes</option>
        <option value="sphere">Sphere</option>
        <option value="ellipse">3D ellipse</option>
        <option value="toroid">toroid</option>
        <option value="elliptical toroid">elliptical toroid</option>
        <option value="elliptical toroid with elliptical cross section">elliptical toroid with elliptical cross section</option>
        </select>
    </form>
    <div id="specifications"></div>
  </div>

  <div class="render-canvas">
      <canvas id="render-canvas"></canvas>
  </div>

  <div id="information" class = "field"></div>

  <div class="slice-canvas">
      <canvas id="slice-canvas" width="600px" height="600px" style="width: 40%; height: 40%; border: 1px solid black;">
      </canvas>
  </div>

  <form id="dataForm">
    <input type="text" id="userInput" placeholder="Enter message">
    <button type="submit">Send to Server</button>
  </form>

  <script>
    const ctx = document.getElementById("slice-canvas").getContext('2d');
    ctx.fillRect(0, 0, 10, 10)

    let shape = document.getElementById("shape");
    let specifications = document.getElementById("specifications");
    let volume = 0;
    let surface = 0;
    let speech = "";
    let mode = "none";

    specifications.addEventListener("submit", function(e) {
      if(mode == "sphere"){
          e.preventDefault();
          let radius = e.target.querySelector("#radius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(radius, radius, radius, parity);
      }
      if(mode == "ellipse"){
          e.preventDefault();
          let width = e.target.querySelector("#width").value.trim();
          let length = e.target.querySelector("#length").value.trim();
          let height = e.target.querySelector("#height").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(width, length, height, parity);
      }
      if(mode == "toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          let angle = e.target.querySelector("#parity").value.trim();
          toroid(minorRadius, minorRadius, majorRadius, majorRadius, parity, angle);
      }
      if(mode == "elliptical toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadiusHeight = e.target.querySelector("#minorRadiusHeight").value.trim();
          let minorRadiusWidth = e.target.querySelector("#minorRadiusWidth").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          let angle = e.target.querySelector("#angle").value.trim();
          toroid(minorRadiusWidth, minorRadiusHeight, majorRadius, majorRadius, parity, angle);
      }
      if(mode == "elliptical toroid with elliptical cross section"){
          e.preventDefault();
          let majorRadiusWidth = e.target.querySelector("#majorRadiusWidth").value.trim();
          let majorRadiusLength = e.target.querySelector("#majorRadiusLength").value.trim();
          let minorRadiusHeight = e.target.querySelector("#minorRadiusHeight").value.trim();
          let minorRadiusWidth = e.target.querySelector("#minorRadiusWidth").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          let angle = e.target.querySelector("#angle").value.trim();
          toroid(minorRadiusHeight, minorRadiusWidth, majorRadiusWidth, majorRadiusLength, parity, angle);
      }
    });

    shape.addEventListener("change", function () {
      specifications.innerHTML = "";
      if (this.value == "sphere") {
        mode = "sphere";
        specifications.innerHTML = `
          <form id="parameters" novalidate>
            <label for="radius">Radius:</label>
            <input type="text" id="radius" name="radius" required>
            <label for="parity">0 (Even) or 1 (Odd)?:</label>
            <input type="text" id="parity" name="parity" required>
            <button type="submit">Generate</button>
          </form>
        `;
      } else if(this.value == "ellipse"){
          mode = "ellipse";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="width">width: </label>
              <input type="text" id="width" name="width" required>
              <label for="length">length:</label>
              <input type="text" id="length" name="length" required>
              <label for="height">height:</label>
              <input type="text" id="height" name="height" required>
              <label for="parity">0 (Even) or 1 (Odd)?: </label>
              <input type="text" id="parity" name="parity" required>
              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "toroid"){
          mode = "toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="text" id="majorRadius" name="majorRadius" required>
              <label for="minorRadius">Minor Radius:</label>
              <input type="text" id="minorRadius" name="minorRadius" required>
              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <label for="angle">Angle:</label>
              <input type="text" id="angle" name="angle" required>
              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid"){
          mode = "elliptical toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="text" id="majorRadius" name="majorRadius" required>
              <label for="minorRadiusHeight">Minor Radius Height:</label>
              <input type="text" id="minorRadiusHeight" name="minorRadiusHeight" required>
              <label for="minorRadiusWidth">Minor Radius Width:</label>
              <input type="text" id="minorRadiusWidth" name="minorRadiusWidth" required>
              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <label for="angle">Angle:</label>
              <input type="text" id="angle" name="angle" required>
              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid with elliptical cross section"){
          mode = "elliptical toroid with elliptical cross section";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadiusWidth">Major Radius Width:</label>
              <input type="text" id="majorRadiusWidth" name="majorRadiusWidth" required>
              <label for="majorRadiusLength">Major Radius Length:</label>
              <input type="text" id="majorRadiusLength" name="majorRadiusLength" required>
              <label for="minorRadiusHeight">Minor Radius Height:</label>
              <input type="text" id="minorRadiusHeight" name="minorRadiusHeight" required>
              <label for="minorRadiusHeight">Minor Radius Width:</label>
              <input type="text" id="minorRadiusHeight" name="minorRadiusHeight" required>
              <label for="parity">0 (Even) or 1 (Odd)?:</label>
              <input type="text" id="parity" name="parity" required>
              <label for="angle">Angle:</label>
              <input type="text" id="angle" name="angle" required>
              <button type="submit">Generate</button>
            </form>
            `;
        }
    });

    function displayInformation(speech){
      information.innerHTML = speech;
    }

    // Babylon startup stuff
    const canvas = document.getElementById("render-canvas");
    const engine = new BABYLON.Engine(canvas);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.9);
    function renderLoop() {
    scene.render();
    }
    engine.runRenderLoop(renderLoop);
    const camera = new BABYLON.ArcRotateCamera(
    "camera",
    Math.PI / 2,
    Math.PI / 4,
    5,
    new BABYLON.Vector3(0, 0, 0),
    scene
    );
    camera.attachControl(canvas, true);

    if('ontouchstart' in window || navigator.maxTouchPoints == 0){
    canvas.addEventListener("wheel", function (event) {
    event.preventDefault();
    }, { passive: false });}

    // Cubes!!!

    let cubes = []
    
    const boxMaterial = new BABYLON.StandardMaterial("material", scene);
    boxMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    const hl = new BABYLON.HighlightLayer("hl", scene);

    function cube(x, y, z){
        cubes.push(BABYLON.Mesh.CreateBox("box", 1, scene))
        cubes[cubes.length - 1].material = boxMaterial;
        cubes[cubes.length - 1].renderOutline = true;
        cubes[cubes.length - 1].outlineColor = BABYLON.Color3.Black();
        cubes[cubes.length - 1].enableEdgesRendering();
        cubes[cubes.length - 1].edgesWidth = 1.0;
        cubes[cubes.length - 1].edgesColor = new BABYLON.Color3(0, 0, 0);
        cubes[cubes.length - 1].position.x = x;
        cubes[cubes.length - 1].position.y = y;
        cubes[cubes.length - 1].position.z = z;
    }

    let map = []
    let anchorPoints = []

    // SPHERE!!

    function volumeQuad(x, y, z){
      // Mostly used by the sphere function to mimic the quad() function to determine volume.
        if(x == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else if (z == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else {
          volume += 4

        if (y != 0){
          volume += 4
        }

        }
    }

    function quad(x, y, z){

      /*
          This is for odd spheres. The line of symetry goes directory through a block, causing it to be drawn twice. If a coordinate is zero, special procedures
          must be used to prevent cubes from being drawn on top of each other.
      */

        if(x == 0){
          cube(x, y, z);
          cube(x, y, -1 * z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(x, -1 * y, -1 * z);
            surface += 2
          }
        } else if (z == 0){
          cube(x, y, z);
          cube(-1 * x, y, z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(-1 * x, -1 * y, z);
            surface += 2
          }
        } else {
          cube(x, y, z);
          cube(-1 * x, y, z);
          cube(x, y, -1 * z);
          cube(-1 * x, y, -1 * z);
          surface += 4

        if (y != 0){
          cube(x, -1 * y, z);
          cube(-1 * x, -1 * y, z);
          cube(x, -1 * y, -1 * z);
          cube(-1 * x, -1 * y, -1 * z);
          surface += 4
        }

        }
    }

    function evenQuad(x, y, z){

      /*
          This is for even sphere where the line of symetry goes in between two cubes. When I mirror cubes, I move them over one to create the even symetry.
          Otherwise this just creates a normal odd sphere.
      */

        cube(x, y, z);
        cube(-1 * x - 1, y, z);
        cube(x, y, -1 * z - 1);
        cube(-1 * x - 1, y, -1 * z - 1);

        cube(x, -1 * y - 1, z);
        cube(-1 * x - 1, -1 * y - 1, z);
        cube(x, -1 * y - 1, -1 * z - 1);
        cube(-1 * x - 1, -1 * y - 1, -1 * z - 1);

        surface += 8

    }
    /*
      In a nutshell, the ellipse function works by checking every single corner of each cube to see if it is less than the radius using the equation
      x^2/w^2 + y^2/h^2 + z^2/l^2 <= 1. Each successful cube placement is inserted into the map[] array for later optimization.

      This function only calculates one eighth of the sphere, the quad() function mirrors the cube across all other "wedges" of the sphere. 
      Every coordinate is at some point multiplied by -1, and in even spheres 1 will also be added as well.
    */

    function ellipse(length, width, height, parity){
      surface = 0;
      volume = 0;
      // filling the map array with 0's
      map = new Array((length + 1) * (width + 1) * (height + 1)).fill(0);
      // Getting rid of all pre existing cubes from other functions
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(parity == "1"){
        // The seed cube
        cube(0, 0, 0);
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                if(y == 0 && x == 0){
                  volume += 2;
                } else if (x == 0 && z == 0){
                  volume += 2;
                } else if (z == 0 && y == 0){
                  volume += 2;
                } else if(y == 0 || z == 0|| x == 0){
                  volume += 4;
                } else {
                  volume += 8;
                }
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y, z);
                      surface += 2;
                    } else {
                      map[y * (width * length) + x * length + z] = 2;
                      quad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if (parity == "0"){
        // The seed cube
        cube(0, 0, 0);
        cube(0, 0, 0);
        cube(-1, 0, 0);
        cube(0, -1, 0);
        cube(-1, -1, 0);
        cube(0, 0, -1);
        cube(-1, 0, -1);
        cube(0, -1, -1);
        cube(-1, -1, -1);
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                volume += 8;
              }
            }
          }
        }
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      evenQuad(x, y, z);
                    } else {
                      map[y * (width * length) + x * length + z] = 2;
                      evenQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }

    /*

// point-in-torus check
// p  = [x,y,z] voxel center
// C  = [cx,cy,cz] torus center
// e1,e2,e3 = orthonormal basis vectors of torus
// R  = major radius
// a,b = ellipse semi-axes (radial, vertical)
function insideTorus(p, C, e1, e2, e3, R, a, b) {
  const q = [p[0]-C[0], p[1]-C[1], p[2]-C[2]];

  const u = dot(q, e1);
  const v = dot(q, e2);
  const w = dot(q, e3);

  const rho = Math.hypot(u, v);

  return ((rho - R)**2) / (a*a) + (w*w) / (b*b) <= 1.0;
}
    */

    function dot(u, v) {
      return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
    }

function toroid(minorRadiusWidth, minorRadiusHeight, majorRadiusLength, majorRadiusWidth, parity, angle) {
  if (parity == "1") {
    
      }
    }

    // Send data
    document.getElementById('dataForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const message = document.getElementById('userInput').value;

      const res = await fetch('/api/data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      });

      const result = await res.json();
      alert(result.status);

      });
  </script>
</body>
</html>