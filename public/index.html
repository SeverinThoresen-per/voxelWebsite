<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.babylonjs.com/v7.34.1/babylon.js"></script>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>
<script>
function sendEvent(name, payload = {}) {
  const data = {
    name,
    url: location.href,
    referrer: document.referrer || null,
    ua: navigator.userAgent,
    ts: Date.now(),
    ...payload
  };
  const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
  navigator.sendBeacon('/track', blob);
}
sendEvent('page_view');
</script>
<body>
  <h1 class="title">Voxel Shape Generator</h1>

  <div class="field">
    <h2 class="header">Spheres, Ovoids, and Toroids</h2>
    <form id="parameters">
        <select name="shape" id="shape" type="shape">
        <option value="none">List of common shapes</option>
        <option value="sphere">Sphere</option>
        <option value="ellipse">3D ellipse</option>
        <option value="toroid">toroid</option>
        <option value="elliptical toroid">elliptical toroid</option>
        <option value="elliptical toroid with elliptical cross section">elliptical toroid with elliptical cross section</option>
        </select>
    </form>
    <div id="specifications"></div>
  </div>
  <div class = "field">
    <h2 class = "header">Lathe</h2>
    <h3 class = "header">Define your own shape using an interval of a function, the line created by this interval is spun 360 degrees to form a 
      radially symetrical shape Single variable functions only with x as the variable, (x + 8)^2.
    </h3>
    <form>
        <select name="lathe" id="lathe" type="lathe">
        <option value="off">Off</option>
        <option value="on">On</option>
        </select>
    </form>
    <div id = "latheSpecifications">
    </div>
  </div>

  <div class="render-canvas">
      <canvas id="render-canvas"></canvas>
        <div id = "slice-manager">
        <button onclick="viewSliceMap()">View slice map</button>
      </div>
  </div>

  <div id="information" class = "field"></div>

  <button id="downloadSurface">Download Surface Coordinates</button>

  <script src="https://cdn.jsdelivr.net/npm/mathjs@13.2.0/lib/browser/math.js"></script>

  <script>

    //Global variables, these reflect the parameters of the current generated shape.

    let sliceMap = false;
    let sliceLayer = 0;
    let boundx = 0;
    let boundy = 0;
    let boundz = 0;
    let globalParity = 0;
    let globalY = 0;
    let usingLathe = false;

    //displySlice takes a y value, iterates through the map[] array using the global bounds,
    //and draws cubes anywhere at the y value where map[] == 1

    function displaySlice(y){
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(globalParity == 1){

          // map[]'s generated by lathes are treated specially because
          // the y values for every slice on a lathe is offset by 1.
          // I.E. There is nothing at y level 0 unlike every other shape.

          for(x = 0; x < boundx; x++){
            for(z = 0; z < boundz; z++){
              if(y >= 1 || (y >= 0 && usingLathe == false)){
                if(map[(y * boundx * boundz) + (x * boundz) + z] == 1){
                    if(x == 0 && z == 0){
                      cube_trackless(x, y, z);
                    } else {
                      latheQuad_trackless(x, y, z);
                    }
                }
              } else if (usingLathe == false) {
                if(map[(-1 * y * boundx * boundz) + (x * boundz) + z] == 1){
                    if(x == 0 && z == 0){
                      cube_trackless(x, y, z);
                    } else {
                      latheQuad_trackless(x, y, z);
                    }
                }
              }

            }
          }
      } else {
      if(globalParity == 0){
          for(x = 0; x < boundx; x++){
            for(z = 0; z < boundz; z++){
              if(y >= 1 || (y >= 0 && usingLathe == false)){
                if(map[(y * boundx * boundz) + (x * boundz) + z] == 1){
                  evenLatheQuad_trackless(x, y, z);
                }
              } else if (usingLathe == false) {
                if(map[((-1 * y - 1) * boundx * boundz) + (x * boundz) + z] == 1){
                  evenLatheQuad_trackless(x, y, z);
                }
              }
            }
          }
      }
      displayInformation("Current layer : " + y);
    }
  }

    //viewSliceMap is responsible for changing the html of the div containing
    // the slicemap options. If the slice map is on, this function turns it off,
    // and vice versa.

    function viewSliceMap(){
      if(sliceMap == false){
        sliceMap = true;
        document.getElementById("slice-manager").innerHTML = `
          <button onclick="viewSliceMap()">View slice map</button>
          <button onclick="upLayer()">Up a layer</button>
          <button onclick="downLayer()">Down a layer</button>
        `
        displaySlice(globalY);
      } else if (sliceMap == true) {
        sliceMap = false;
        document.getElementById("slice-manager").innerHTML = `
          <button onclick="viewSliceMap()">View slice map</button>
        `
      }
    }

    //Both upLayer and downLayer call displaySlice at the current
    // globalY value, offset by one.

    function upLayer(){
      globalY += 1;
      displaySlice(globalY);
    }

    function downLayer(){
      globalY -= 1;
      displaySlice(globalY);
    }

    //Global variables, these are basic references used to attach the javascript to the html

    let shape = document.getElementById("shape");
    let lathe = document.getElementById("lathe");
    let specifications = document.getElementById("specifications");
    let latheSpecifications = document.getElementById("latheSpecifications");
    let volume = 0;
    let surface = 0;
    let speech = "";
    let mode = "none";

    //This listens for when the user changes the dropdown in the lathe div, and
    //applies the appropriate html.

    lathe.addEventListener("change", function(e){
      if(this.value == "on"){
            latheSpecifications.innerHTML = `
            <form id="latheParameters" novalidate>
            <label for="formula">Formula: </label>
            <input type="text" id="formula" name="formula" required>

            <label for="index1">Index 1: </label>
            <input type="text" id="index1" name="index1" required>

            <label for="index2">Index 2: </label>
            <input type="text" id="index2" name="index2" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>

            <button type="submit">Generate</button>
          </form>
      `
      } else {
        latheSpecifications.innerHTML = "";
      }
    })
    
    //This grabs the values from the lathe div and calls the lathe function

    latheSpecifications.addEventListener("submit", function(e){
      e.preventDefault();
      let equation = e.target.querySelector("#formula").value.trim();
      let index1 = e.target.querySelector("#index1").value.trim();
      let index2 = e.target.querySelector("#index2").value.trim();
      let parity = e.target.querySelector("#parity").value.trim();
      latheFunc(equation, index1, index2, parity);
    })

    //This grabs the values of whatever common shape happens to be selected

    specifications.addEventListener("submit", function(e) {
      if(mode == "sphere"){
          e.preventDefault();
          let radius = e.target.querySelector("#radius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(radius, radius, radius, parity);
      }
      if(mode == "ellipse"){
          e.preventDefault();
          let width = e.target.querySelector("#width").value.trim();
          let length = e.target.querySelector("#length").value.trim();
          let height = e.target.querySelector("#height").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          ellipse(width, length, height, parity);
      }
      if(mode == "toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(1, 1, 1, majorRadius, minorRadius, parity);
      }
      if(mode == "elliptical toroid"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let widthScale = e.target.querySelector("#widthScale").value.trim();
          let lengthScale = e.target.querySelector("#lengthScale").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(widthScale, lengthScale, 1,majorRadius, minorRadius, parity);
      }
      if(mode == "elliptical toroid with elliptical cross section"){
          e.preventDefault();
          let majorRadius = e.target.querySelector("#majorRadius").value.trim();
          let minorRadius = e.target.querySelector("#minorRadius").value.trim();
          let widthScale = e.target.querySelector("#widthScale").value.trim();
          let lengthScale = e.target.querySelector("#lengthScale").value.trim();
          let heightScale = e.target.querySelector("#heightScale").value.trim();
          let parity = e.target.querySelector("#parity").value.trim();
          toroid(widthScale, lengthScale, heightScale, majorRadius, minorRadius, parity);
      }
    });

    //This listens for when the user changes the dropdown in the common shapes div, and
    //applies the appropriate html.

    shape.addEventListener("change", function () {
      specifications.innerHTML = "";
      if (this.value == "sphere") {
        mode = "sphere";
        specifications.innerHTML = `
          <form id="parameters" novalidate>
            <label for="radius">Radius:</label>

            <input type="number" min="0" step="1" id="radius" name="radius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>

            <button type="submit">Generate</button>
          </form>
        `;
      } else if(this.value == "ellipse"){
          mode = "ellipse";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="width">width: </label>
              <input type="number" min="0" step="1" id="width" name="width" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

              <label for="length">length:</label>
              <input type="number" min="0" step="1" id="length" name="length" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

              <label for="height">height:</label>
              <input type="number" min="0" step="1" id="height" name="height" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>

              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "toroid"){
          mode = "toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="number" min="0" step="1" id="majorRadius" name="majorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="number" min="0" step="1" id="minorRadius" name="minorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>

              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid"){
          mode = "elliptical toroid";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="number" min="0" step="1" id="majorRadius" name="majorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

              <label for="widthScale">Width Scale:</label>
              <input type="number" step="0.001" id="widthScale" name="widthScale" required>

              <label for="lengthScale">Length Scale:</label>
              <input type="number" step="0.001" id="lengthScale" name="lengthScale" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="number" step="1" min="0" id="minorRadius" name="minorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>

              <button type="submit">Generate</button>
            </form>
            `;
        } else if(this.value == "elliptical toroid with elliptical cross section"){
          mode = "elliptical toroid with elliptical cross section";
            specifications.innerHTML = `
            <form id="parameters">
              <label for="majorRadius">Major Radius:</label>
              <input type="number" min="0" step="1" id="majorRadius" name="majorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

              <label for="widthScale">Width Scale:</label>
              <input type="number" step="0.001" id="widthScale" name="widthScale" required>

              <label for="lengthScale">Length Scale:</label>
              <input type="number" step="0.001" id="lengthScale" name="lengthScale" required>

              <label for="heightScale">Height Scale:</label>
              <input type="number" step="0.001" id="heightScale" name="heightScale" required>

              <label for="minorRadius">Minor Radius:</label>
              <input type="number" step="1" min="0" id="minorRadius" name="minorRadius" oninput="this.value = this.value.replace(/[^0-9\-]/g, '')" required>

            <label for="parity">Even or Odd?</label>
              <select name="parity" id="parity" type="parity">
                <option value="1">Odd</option>
                <option value="0">Even</option>
              </select>
            
              <button type="submit">Generate</button>
            </form>
            `;
        }
    });

    //This function is generally used to display the volume and surface area on the page,
    //it's also used to display the y value of the current layer if the slice map is on

    function displayInformation(speech){
      information.innerHTML = speech;
    }

    // Babylon startup stuff

    const canvas = document.getElementById("render-canvas");
    const engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: true,
      stencil: true
    });
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.9);
    function renderLoop() {
    scene.render();
    }
    engine.runRenderLoop(renderLoop);
    const camera = new BABYLON.ArcRotateCamera(
    "camera",
    Math.PI / 2,
    Math.PI / 4,
    5,
    new BABYLON.Vector3(0, 0, 0),
    scene
    );
    camera.attachControl(canvas, true);

    if('ontouchstart' in window || navigator.maxTouchPoints == 0){
    canvas.addEventListener("wheel", function (event) {
    event.preventDefault();
    }, { passive: false });}

    let cubes = []
    
    const boxMaterial = new BABYLON.StandardMaterial("material", scene);
    boxMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    const hl = new BABYLON.HighlightLayer("hl", scene);

    //These are identical to their non trackless functions with one difference.
    //They do not update the surface map when called, which makes rendering slices
    //based on the current surface map much easier.

    function cube_trackless(x, y, z){
        cubes.push(BABYLON.Mesh.CreateBox("box", 1, scene))
        cubes[cubes.length - 1].material = boxMaterial;
        cubes[cubes.length - 1].renderOutline = true;
        cubes[cubes.length - 1].outlineColor = BABYLON.Color3.Black();
        cubes[cubes.length - 1].enableEdgesRendering();
        cubes[cubes.length - 1].edgesWidth = 1.0;
        cubes[cubes.length - 1].edgesColor = new BABYLON.Color3(0, 0, 0);
        cubes[cubes.length - 1].position.x = x;
        cubes[cubes.length - 1].position.y = y;
        cubes[cubes.length - 1].position.z = z;
    }

    function latheQuad_trackless(x, y, z){
        if(x == 0 && z == 0){
          cube_trackless(x,y,z);
          surface += 1
        } else if(x == 0){
          cube_trackless(x, y, z);
          cube_trackless(x, y, -1 * z);
          surface += 2
        } else if (z == 0){
          cube_trackless(x, y, z);
          cube_trackless(-1 * x, y, z);
          surface += 2
        } else {
          cube_trackless(x, y, z);
          cube_trackless(-1 * x, y, z);
          cube_trackless(x, y, -1 * z);
          cube_trackless(-1 * x, y, -1 * z);
          surface += 4

        }
    }

    function evenLatheQuad_trackless(x,y,z){
        cube_trackless(x, y, z);
        cube_trackless(-1 * x - 1, y, z);
        cube_trackless(x, y, -1 * z - 1);
        cube_trackless(-1 * x - 1, y, -1 * z - 1);

        surface += 4
    }

    //This function draws a cube at the coordinates passed to it

    function cube(x, y, z){
        cubes.push(BABYLON.Mesh.CreateBox("box", 1, scene))
        cubes[cubes.length - 1].material = boxMaterial;
        cubes[cubes.length - 1].renderOutline = true;
        cubes[cubes.length - 1].outlineColor = BABYLON.Color3.Black();
        cubes[cubes.length - 1].enableEdgesRendering();
        cubes[cubes.length - 1].edgesWidth = 1.0;
        cubes[cubes.length - 1].edgesColor = new BABYLON.Color3(0, 0, 0);
        cubes[cubes.length - 1].position.x = x;
        cubes[cubes.length - 1].position.y = y;
        cubes[cubes.length - 1].position.z = z;

        surfaceMap.push({x,y,z});
    }
    
    //map is entirely filled with 1's and 0's, it's generally massive,
    //and every index in map is based on the coordinates of any given voxel.

    let map = [];

    //surface map contains 3d coordinates of every rendered cube.

    let surfaceMap = [];

    //These two arrays serve no purpose, but I might use them later so I'll keep them
      
    let fullMap = [];
    let anchorPoints = [];

    //These volume functions mimic their non volume counterparts, with one exception.
    //Instead of placing cubes, these functions update the global volume variable instead

    function volumeQuad(x, y, z){
        if(x == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else if (z == 0){
          volume += 2
          if(y != 0){
            volume += 2
          }
        } else {
          volume += 4

        if (y != 0){
          volume += 4
        }

        }
    }

    function volumeLatheQuad(x,y,z){
        if(x == 0 && z == 0){
          volume += 1
        } else if(x == 0){
          volume += 2
        } else if (z == 0){
          volume += 2
        } else {
          volume += 4

        }
    }

    //Only one eighth of any given shape (except for lathes)
    //is actually calculated to increase calculation speed.
    //To form a full shape, each calulated cube needs to be mirrored
    //anywhere from 2 to 8 times.

    //quad and latheQuad are for "odd" shapes, that is the line of symetry
    //goes straight down a single cube, which means that any cube with any coordinate that equals 0
    //must be given special attention to avoid drawing cubes in the same place.

    function quad(x, y, z){

        if(x == 0){
          cube(x, y, z);
          cube(x, y, -1 * z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(x, -1 * y, -1 * z);
            surface += 2
          }
        } else if (z == 0){
          cube(x, y, z);
          cube(-1 * x, y, z);
          surface += 2
          if(y != 0){
            cube(x, -1 * y, z);
            cube(-1 * x, -1 * y, z);
            surface += 2
          }
        } else {
          cube(x, y, z);
          cube(-1 * x, y, z);
          cube(x, y, -1 * z);
          cube(-1 * x, y, -1 * z);
          surface += 4

        if (y != 0){
          cube(x, -1 * y, z);
          cube(-1 * x, -1 * y, z);
          cube(x, -1 * y, -1 * z);
          cube(-1 * x, -1 * y, -1 * z);
          surface += 4
        }

        }
    }

    //latheQuad is the same as quad, but for the lathe. Unlike quad, latheQuad does not mirror cubes
    //across the xz plane. This also makes it useful for the slicemap.

    function latheQuad(x, y, z){
        if(x == 0 && z == 0){
          cube(x,y,z);
          surface += 1
        } else if(x == 0){
          cube(x, y, z);
          cube(x, y, -1 * z);
          surface += 2
        } else if (z == 0){
          cube(x, y, z);
          cube(-1 * x, y, z);
          surface += 2
        } else {
          cube(x, y, z);
          cube(-1 * x, y, z);
          cube(x, y, -1 * z);
          cube(-1 * x, y, -1 * z);
          surface += 4

        }
    }

    //evenQuad and evenLatheQuad are designed for "even" shapes, the line of symetry
    //goes perfectly inbetween cubes. This makes mirroring much simpler because I don't
    //have to worry about cubes getting drawn in exactly the same place.

    function evenQuad(x, y, z){

      /*
          This is for even sphere where the line of symetry goes in between two cubes. When I mirror cubes, I move them over one to create the even symetry.
          Otherwise this just creates a normal odd sphere.
      */

        cube(x, y, z);
        cube(-1 * x - 1, y, z);
        cube(x, y, -1 * z - 1);
        cube(-1 * x - 1, y, -1 * z - 1);

        cube(x, -1 * y - 1, z);
        cube(-1 * x - 1, -1 * y - 1, z);
        cube(x, -1 * y - 1, -1 * z - 1);
        cube(-1 * x - 1, -1 * y - 1, -1 * z - 1);

        surface += 8

    }
    
    function evenLatheQuad(x,y,z){
        cube(x, y, z);
        cube(-1 * x - 1, y, z);
        cube(x, y, -1 * z - 1);
        cube(-1 * x - 1, y, -1 * z - 1);

        surface += 4
    }
    
    /*
      In a nutshell, the ellipse function works by checking every single corner of each cube to see if it is less than the radius using the equation
      x^2/w^2 + y^2/h^2 + z^2/l^2 <= 1. Each successful cube placement is inserted into the map[] array for later optimization.

      This function only calculates one eighth of the sphere, the quad() function mirrors the cube across all other "wedges" of the sphere. 
      Every coordinate is at some point multiplied by -1, and in even spheres 1 will also be added as well.
    */

    function ellipse(length, width, height, parity){
      surfaceMap = [];
      fullMap = [];
      usingLathe = false;
      surface = 0;
      volume = 0;
      boundx = width;
      boundy = height;
      boundz = length;
      sliceMap = true;
      viewSliceMap();
      // filling the map array with 0's
      map = new Array((length + 1) * (width + 1) * (height + 1)).fill(0);
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              map[(y * width * length) + (x * length) + z] = 0;
            }
          }
        }
      // Getting rid of all pre existing cubes from other functions
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(parity == "1"){
        globalParity = 1;
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                if(y == 0 && x == 0){
                  volume += 2;
                } else if (x == 0 && z == 0){
                  volume += 2;
                } else if (z == 0 && y == 0){
                  volume += 2;
                } else if(y == 0 || z == 0|| x == 0){
                  volume += 4;
                } else {
                  volume += 8;
                }
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y, z);
                      surface += 2;
                    } else {
                      quad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if (parity == "0"){
        globalParity = 0;
        for(y = 0; y <= height; y++){
          for(x = 0; x <= width; x++){
            for(z = 0; z <= length; z++){
              // this is the heart of the sphere function, and applies the formula mentioned at the top of the sphere function.
              if((x + 0.5)*(x + 0.5)/(width * width) + (y + 0.5)*(y + 0.5)/(height * height) + (z + 0.5)*(z + 0.5)/(length * length) <= 1){
                map[(y * width * length) + (x * length) + z] = 1;
                volume += 8;
              }
            }
          }
        }
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */
        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1){
                  if(map[y * (width * length) + x * length + z] == 1){
                    if(x == 0 && z == 0){
                      evenQuad(x, y, z);
                    } else {
                      evenQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }

    /*
      The toroid function works similarly to the ellipse() function, but the equation is :
      (Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r

      This function only calculates one eighth of the sphere, the quad() function mirrors the cube across all other "wedges" of the sphere. 
      Every coordinate is at some point multiplied by -1, and in even spheres 1 will also be added as well.
    */

  function toroid(scaleWidth, scaleLength, scaleHeight, majorRadius, minorRadius, parity) {
      surfaceMap = [];
      fullMap = [];
      usingLathe = false;
      sliceMap = true;
      viewSliceMap();

      surface = 0;
      volume = 0;
      let a = scaleWidth;
      let b = scaleLength;
      let c = scaleHeight;
      let R = majorRadius;
      let r = minorRadius;

      let width = (parseInt(majorRadius) + parseInt(minorRadius)) * Math.ceil(scaleWidth);
      let length = parseInt(minorRadius) * parseInt(scaleHeight);
      let height = (parseInt(majorRadius) + parseInt(minorRadius)) * Math.ceil(scaleLength);
      
      boundx = width;
      boundy = height;
      boundz = length;
      // filling the map array with 0's
      map = new Array((majorRadius * Math.ceil(scaleWidth) + 1) * (majorRadius * Math.ceil(scaleLength) + 1) * (minorRadius * Math.ceil(scaleHeight) + 1)).fill(0);

      //I made my own psudo .fill(0) function because for whatever reason, 
      // .fill(0) does not actually fill every voxel with a 0. I'm not sure why, but I made this to fix it.

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              map[(y * width * length) + (x * length) + z] = 0;
            }
          }
        }

      // Getting rid of all pre existing cubes from other functions
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      if(parity == "1"){ 
        globalParity = 1;
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if((Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r){
                map[(y * width * length) + (x * length) + z] = 1;
                if(y == 0 && x == 0){
                  volume += 2;
                } else if (x == 0 && z == 0){
                  volume += 2;
                } else if (z == 0 && y == 0){
                  volume += 2;
                } else if(y == 0 || z == 0|| x == 0){
                  volume += 4;
                } else {
                  volume += 8;
                }
              }
            }
          }
        }
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if(x*x + y*y + z*z < Math.pow(majorRadius - minorRadius,2)){
                map[(y * width * length) + (x * length) + z] = 0;
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor. I only check in three directions because we are technically not working with a sphere, but a more
          of a rounded wedge. This means some of the cubes are missed, but I will get them later.
        */

        map[height * (width * length) + 0 * length + 0] = 0

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1
              || (map[y * (width * length) + (x - 1) * length + z] == 0 && x != 0)
              || map[(y - 1) * (width * length) + x * length + z] == 0){
                  if(map[y * (width * length) + x * length + z] == 1 && x != width){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y, z);
                      surface += 2;
                    } else {
                      quad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if (parity == "0"){
        globalParity = 0;
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              //This is the kernel of the toroid function. This is the equation that determines what voxels should be considered filled.
              if((Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R)*(Math.sqrt((x/a)*(x/a) + (y/b)*(y/b)) - R) + (z/c)*(z/c) <= r*r){
                map[(y * width * length) + (x * length) + z] = 1;
                volume += 8;
              }
            }
          }
        }
        // There were issues with generating the middle of the toroid. There were small "growths" on the edges and in the center of the hole
        // This function basically clears the entire center to make sure those growths do not occur.
        for(y = 0; y <= (majorRadius + minorRadius) * scaleLength; y++){
          for(x = 0; x <= (majorRadius + minorRadius) * scaleWidth; x++){
            for(z = 0; z <= (minorRadius) * scaleHeight; z++){
              if(x*x + y*y + z*z < Math.pow(majorRadius - minorRadius,2)){
                map[(y * width * length) + (x * length) + z] = 0;
              }
            }
          }
        }
        volume -= 1;
        /*
          Rendering every single cube is very resource intensive, so I only spawn cubes that are on the outside of the sphere. I do this by checking every single
          cube to see if one of their sides has no neighbor.
        */

        map[height * (width * length) + 0 * length + 0] = 0

        for(y = height; y >= 0; y--){
          for(x = width - 1; x >= 0; x--){
            for(z = length - 1; z >= 0; z--){
              if(map[(y + 1) * (width * length) + x * length + z] == 0 
              || map[y * (width * length) + (x + 1) * length + z] == 0
              || map[y * (width * length) + x * length + (z + 1)] == 0
              || z == length - 1 || x == width - 1
              || (map[y * (width * length) + (x - 1) * length + z] == 0 && x != 0)
              || map[(y - 1) * (width * length) + x * length + z] == 0){
                  if(map[y * (width * length) + x * length + z] == 1 && x != width){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      cube(x, -1 * y - 1, z);
                      cube(x - 1, y, z);
                      cube(x - 1, -1 * y - 1, z);

                      cube(x, y, z - 1);
                      cube(x, -1 * y - 1, z - 1);
                      cube(x - 1, y, z - 1);
                      cube(x - 1, -1 * y - 1, z - 1);
                      surface += 8;
                    } else {
                      evenQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }

    /*
      This is the lathe function. It runs a for loop from index1 to index2, inputs those indexes into the equation,
      and takes the output of the equation at any given index as the radius of a circle to be drawn. It essentially
      swivels a given function around the y axis to create a 3d shape
    */

    function latheFunc(equation, index1, index2, parity){
      surfaceMap = [];
      fullMap = [];
      usingLathe = true;
      surface = 0;
      volume = 0;
      sliceMap = true;
      viewSliceMap();
      scene.meshes.slice().forEach(mesh => mesh.dispose());
      let expr = math.parse(equation);
      let F = (val) => expr.evaluate({ x: val });
      let secondIndex = 0;
      let firstIndex = 0;
      index1 = Math.abs(index1);
      index2 = Math.abs(index2);
      if(index1 < index2){
        firstIndex = index1;
        secondIndex = index2;
      } else if (index2 <= index1){
        firstIndex = index2;
        secondIndex = index1;
      }
      let radius = 0;
      let y = 0;
      let radiusStack = [];
        for(y = firstIndex; y <= secondIndex; y++){
          if(F(y) < 0){
            radiusStack.push(0);
          } else {
            radiusStack.push(Math.floor(F(y)));
          }
          if(F(y) > radius){
            radius = Math.floor(F(y)) + 1;
          }
        }
        boundx = radius;
        boundy = radiusStack.length - 1;
        boundz = radius;     
      if(parity == "1"){
        globalParity = 1;
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius; x++){
            for(z = 0; z <= radius; z++){
              if((x + 0.5)*(x + 0.5) + (z + 0.5)*(z + 0.5) <= radiusStack[y] * radiusStack[y]){
                map[((y) * radius * radius) + (x * radius) + z] = 1;
                volumeLatheQuad(x,y,z)
              } else {
                map[((y) * radius * radius) + (x * radius) + z] = 0;
              }
            }
          }
        }
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius - 1; x++){
            for(z = 0; z <= radius - 1; z++){
              if(map[(y + 1) * (radius * radius) + x * radius + z] == 0 
              || map[y * (radius * radius) + (x + 1) * radius + z] == 0
              || map[y * (radius * radius) + x * radius + (z + 1)] == 0
              || z == radius - 1 || x == radius - 1 || y == 1
              || (map[y * (radius * radius) + (x - 1) * radius + z] == 0 && x != 0)
              || map[(y - 1) * (radius * radius) + x * radius + z] == 0){
                  if(map[y * (radius * radius) + x * radius + z] == 1 && x != radius && y != 0){
                    if(x == 0 && z == 0){
                      cube(x, y, z);
                      surface += 1;
                    } else {
                      latheQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      } else if(parity == "0"){
        globalParity = 0;
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius; x++){
            for(z = 0; z <= radius; z++){
              if((x + 0.5)*(x + 0.5) + (z + 0.5)*(z + 0.5) <= radiusStack[y] * radiusStack[y]){
                map[((y) * radius * radius) + (x * radius) + z] = 1;
                volume += 4;
              } else {
                map[((y) * radius * radius) + (x * radius) + z] = 0;
              }
            }
          }
        }
        for(y = 0; y <= radiusStack.length; y++){
          for(x = 0; x <= radius - 1; x++){
            for(z = 0; z <= radius - 1; z++){
              if(map[(y + 1) * (radius * radius) + x * radius + z] == 0 
              || map[y * (radius * radius) + (x + 1) * radius + z] == 0
              || map[y * (radius * radius) + x * radius + (z + 1)] == 0
              || z == radius - 1 || x == radius - 1 || y == 1
              || (map[y * (radius * radius) + (x - 1) * radius + z] == 0 && x != 0)
              || map[(y - 1) * (radius * radius) + x * radius + z] == 0){
                  if(map[y * (radius * radius) + x * radius + z] == 1 && x != radius && y != 0){
                    if(x == 0 && z == 0){
                      evenLatheQuad(x, y, z);
                      surface += 1;
                    } else {
                      evenLatheQuad(x, y, z);
                    }
                  }
              }
            }
          }
        }
      }
      if(true){
        speech = "Total volume of the shape is : " + volume + ", " + surface + " required for the surface";
      } else {
        speech = "Radius is too small for calculations";
      }
      displayInformation(speech);
    }
    // Send data
    document.getElementById('dataForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const message = document.getElementById('userInput').value;

      const res = await fetch('/api/data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      });

      const result = await res.json();
      alert(result.status);

      });

      document.getElementById("downloadSurface").addEventListener("click", function () {
        let text = "";
        for(i = 0; i < surfaceMap.length; i++){
          text += "[" + surfaceMap[i].x + "," + surfaceMap[i].y + "," + surfaceMap[i].z + "]" + ",";
        }
        const blob = new Blob([text], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "sample.txt";
        a.click();
        URL.revokeObjectURL(url); // cleanup
      });
  </script>
</body>
</html>